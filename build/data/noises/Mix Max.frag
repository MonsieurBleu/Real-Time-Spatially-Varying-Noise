#include ../../data/noises/utils.glsl
#include functions/FiltrableNoises.glsl

#define HIST_SIZE 128

struct ProceduralProcess
{
    vec2 uv;
    float value;
    float mean;
    // float histogram[HIST_SIZE+2];
    float histogram[HIST_SIZE];
};

float ProceduralPriority_HIST_SIZE(ProceduralProcess p)
{
    // float sv = p.value*(HIST_SIZE-2);
    // int id = int(floor(sv));   
    // return mix(p.histogram[id], p.histogram[id+1], fract(sv));



    float sv = p.value*(HIST_SIZE);
    int id = int(floor(sv)); 

    float v1 = id <= 0 ? 0. : p.histogram[id-1];

    float v2 = id >= HIST_SIZE ? 1. : p.histogram[id];
    return mix(v1, v2, fract(sv));
}

void FlattenMixedPriorty_case1(in out float po, float alpha)
{
    float alphaD = distance(alpha, .5);
    float d = (1. - sqrt(1. - 2.*alphaD));

    po = (po-d)/(1.-d);
    po *= po;
}

void FlattenMixedPriorty_case2(in out float po, float alpha)
{
    float alphaD = distance(alpha, .5);
    float d = (1. - sqrt(1. - 2.*alphaD));

    float m = d*d;
    float t = 2. - sqrt(2.*alphaD);

    if(po < 1.-d)
    {
        po += d;    
        po = (1.-t*d)*((po*po)-m)/(1.-m);
    }
    else
    {
        po = t*(po-(1.-d)) + 1.-t*d;
    }
}


vec2 MixMaxNaive_Flat(float v1, float p1, float v2, float p2, float alpha)
{
    float alphaD = distance(alpha, .5);
    float d = (1. - sqrt(1. - 2.*alphaD));
    float p1_shifted = p1 + sign(alpha-.5)*d;

    if(p1_shifted > p2)
    {
        if(alpha > .5)
            FlattenMixedPriorty_case2(p1, alpha);
        else
            FlattenMixedPriorty_case1(p1, alpha);
        
        return vec2(0., p1);
    }
    else
    {
        if(alpha > .5)
            FlattenMixedPriorty_case1(p2, alpha);
        else
            FlattenMixedPriorty_case2(p2, alpha);
        
        return vec2(1., p2);
    }
}

vec2 MixMaxNaive_Original(float v1, float p1, float v2, float p2, float alpha)
{
    float p1_shifted = p1 + alpha;
    float p2_shifted = p2 + 1.-alpha;

    if(p1_shifted > p2_shifted)
        return vec2(0., p1);
    else
        return vec2(1., p2);
}

vec2 MixMaxMicro_Original(
    float v1, float p1, float m1,
    float v2, float p2, float m2,
    float alpha)
{   
    p1 = 2.*p1-1.;
    p2 = 2.*p2-1.;
    alpha = 2.*alpha-1.;

    float CDF = .5 + .5*tanh(0.85*alpha);

    return vec2(
        clamp(1. - CDF*((p1 + alpha)-(p2 - alpha)/sqrt(m1*m1+m2*m2)), 0., 1.), 
        0.
        );
}

vec2 MixMaxMicro_Flat(
    float v1, float p1, float m1,
    float v2, float p2, float m2,
    float alpha)
{   
    p1 = 2.*p1-1.;
    p2 = 2.*p2-1.;
    // alpha = 2.*alpha-1.;

    float alphaD = distance(alpha, .5);
    float d = (1. - sqrt(1. - 2.*alphaD));

    p1 += sign(alpha-.5)*d;
    p2 -= sign(alpha-.5)*d;

    return vec2(
        clamp(1. - (p1-p2)/sqrt(m1*m1+m2*m2), 0., 1.), 
        0.
        );
}


void main()
{
    UV_PREPROCESS


    // ProceduralProcess inputs[16];


    ProceduralProcess voronoi;
    voronoi.uv = auv*100. * .2;


    vec3 tmpvorcenter;
    voronoi.value = voronoi3d(vec3(voronoi.uv, 0.), tmpvorcenter).r*.95 - 0.025;
    voronoi.value = 1. - clamp(voronoi.value, 0., 1.);

    // 256 + 2
    // voronoi.histogram = float[](0., 9.88071e-05, 0.000118784, 0.000139302, 0.000164408, 0.000193565, 0.000218941, 0.000251067, 0.000288862, 0.000335566, 0.000382, 0.000440312, 0.000504294, 0.000574755, 0.000659524, 0.000756711, 0.000859838, 0.000977272, 0.00111792, 0.00126047, 0.0014273, 0.00160899, 0.00181065, 0.00204201, 0.00228147, 0.0025482, 0.00284759, 0.0031513, 0.00350765, 0.00389829, 0.00431377, 0.00475867, 0.00522625, 0.0057678, 0.00631906, 0.00690732, 0.00755307, 0.00822879, 0.00893988, 0.00970712, 0.0105467, 0.0114292, 0.0123776, 0.0133576, 0.0144169, 0.0155106, 0.0167313, 0.0180069, 0.019337, 0.0208262, 0.0223002, 0.023826, 0.0254563, 0.027162, 0.0289591, 0.0308494, 0.0327896, 0.0348694, 0.0370305, 0.0392542, 0.0416429, 0.0440788, 0.0465859, 0.0492515, 0.0519787, 0.0550658, 0.0580484, 0.0611735, 0.0644047, 0.0677061, 0.0711716, 0.0747076, 0.0783648, 0.0821692, 0.0860934, 0.0900902, 0.0941883, 0.0984756, 0.102905, 0.107425, 0.112048, 0.117075, 0.121972, 0.126953, 0.132098, 0.137335, 0.142775, 0.148293, 0.153926, 0.159667, 0.16558, 0.171575, 0.177664, 0.183893, 0.190229, 0.196745, 0.203284, 0.210379, 0.217139, 0.224014, 0.23102, 0.238113, 0.245294, 0.252513, 0.2598, 0.26719, 0.274719, 0.282346, 0.289972, 0.297832, 0.305663, 0.313493, 0.321483, 0.330032, 0.338165, 0.3464, 0.354646, 0.363021, 0.371418, 0.379851, 0.388268, 0.396772, 0.405191, 0.413762, 0.422237, 0.430832, 0.439537, 0.448128, 0.457349, 0.465943, 0.474547, 0.483175, 0.491774, 0.500346, 0.508928, 0.517608, 0.526226, 0.534796, 0.543408, 0.551962, 0.56044, 0.568858, 0.577276, 0.585696, 0.594511, 0.602807, 0.611024, 0.619169, 0.627295, 0.6354, 0.643483, 0.651422, 0.659316, 0.667123, 0.674857, 0.682521, 0.690151, 0.69764, 0.705096, 0.712445, 0.720169, 0.727364, 0.734483, 0.741442, 0.748417, 0.755259, 0.761994, 0.768561, 0.775179, 0.781637, 0.787971, 0.794235, 0.800379, 0.806393, 0.812297, 0.818166, 0.824265, 0.829907, 0.8355, 0.840923, 0.846219, 0.851416, 0.856512, 0.861544, 0.866422, 0.871237, 0.875929, 0.880553, 0.884991, 0.88937, 0.893591, 0.897737, 0.902062, 0.906042, 0.909903, 0.913676, 0.917313, 0.920899, 0.924383, 0.92781, 0.931005, 0.934175, 0.937235, 0.940214, 0.943093, 0.945849, 0.948507, 0.951152, 0.95384, 0.956294, 0.958599, 0.960842, 0.963036, 0.965156, 0.967127, 0.969085, 0.970926, 0.972722, 0.974429, 0.976067, 0.977602, 0.979054, 0.980461, 0.981806, 0.983158, 0.984375, 0.985515, 0.986576, 0.98759, 0.988565, 0.989512, 0.990356, 0.991156, 0.991902, 0.992612, 0.993267, 0.993902, 0.99446, 0.994979, 0.995476, 0.995938, 0.996331, 0.996678, 0.996996, 0.997287, 0.997554, 0.997791, 0.997998, 0.998188, 0.998351, 0.998486, 0.998592, 0.998681, 0.998754, 0.998815, 0.998869, 0.998959, 1.);
    
    // 126 + 2
    voronoi.histogram = float[](0.000139302, 0.000193565, 0.000251067, 0.000335566, 0.000440312, 0.000574755, 0.000756711, 0.000977272, 0.00126047, 0.00160899, 0.00204201, 0.0025482, 0.0031513, 0.00389829, 0.00475867, 0.0057678, 0.00690732, 0.00822879, 0.00970712, 0.0114292, 0.0133576, 0.0155106, 0.0180069, 0.0208262, 0.023826, 0.027162, 0.0308494, 0.0348694, 0.0392542, 0.0440788, 0.0492515, 0.0550658, 0.0611735, 0.0677061, 0.0747076, 0.0821692, 0.0900902, 0.0984756, 0.107425, 0.117075, 0.126953, 0.137335, 0.148293, 0.159667, 0.171575, 0.183893, 0.196745, 0.210379, 0.224014, 0.238113, 0.252513, 0.26719, 0.282346, 0.297832, 0.313493, 0.330032, 0.3464, 0.363021, 0.379851, 0.396772, 0.413762, 0.430832, 0.448128, 0.465943, 0.483175, 0.500346, 0.517608, 0.534796, 0.551962, 0.568858, 0.585696, 0.602807, 0.619169, 0.6354, 0.651422, 0.667123, 0.682521, 0.69764, 0.712445, 0.727364, 0.741442, 0.755259, 0.768561, 0.781637, 0.794235, 0.806393, 0.818166, 0.829907, 0.840923, 0.851416, 0.861544, 0.871237, 0.880553, 0.88937, 0.897737, 0.906042, 0.913676, 0.920899, 0.92781, 0.934175, 0.940214, 0.945849, 0.951152, 0.956294, 0.960842, 0.965156, 0.969085, 0.972722, 0.976067, 0.979054, 0.981806, 0.984375, 0.986576, 0.988565, 0.990356, 0.991902, 0.993267, 0.99446, 0.995476, 0.996331, 0.996996, 0.997554, 0.997998, 0.998351, 0.998592, 0.998754, 0.998869, 0.998959);
    
    // 62 + 2
    // voronoi.histogram = float[](0.000193565, 0.000335566, 0.000574755, 0.000977272, 0.00160899, 0.0025482, 0.00389829, 0.0057678, 0.00822879, 0.0114292, 0.0155106, 0.0208262, 0.027162, 0.0348694, 0.0440788, 0.0550658, 0.0677061, 0.0821692, 0.0984756, 0.117075, 0.137335, 0.159667, 0.183893, 0.210379, 0.238113, 0.26719, 0.297832, 0.330032, 0.363021, 0.396772, 0.430832, 0.465943, 0.500346, 0.534796, 0.568858, 0.602807, 0.6354, 0.667123, 0.69764, 0.727364, 0.755259, 0.781637, 0.806393, 0.829907, 0.851416, 0.871237, 0.88937, 0.906042, 0.920899, 0.934175, 0.945849, 0.956294, 0.965156, 0.972722, 0.979054, 0.984375, 0.988565, 0.991902, 0.99446, 0.996331, 0.997554, 0.998351, 0.998754, 0.998959);

    // 30 + 2
    // voronoi.histogram = float[](0.000335566, 0.000977272, 0.0025482, 0.0057678, 0.0114292, 0.0208262, 0.0348694, 0.0550658, 0.0821692, 0.117075, 0.159667, 0.210379, 0.26719, 0.330032, 0.396772, 0.465943, 0.534796, 0.602807, 0.667123, 0.727364, 0.781637, 0.829907, 0.871237, 0.906042, 0.934175, 0.956294, 0.972722, 0.984375, 0.991902, 0.996331, 0.998351, 0.998959);

    // 14 + 2
    // voronoi.histogram = float[](0.000977272, 0.0057678, 0.0208262, 0.0550658, 0.117075, 0.210379, 0.330032, 0.465943, 0.602807, 0.727364, 0.829907, 0.906042, 0.956294, 0.984375, 0.996331, 0.998959);

    // voronoi.histogram = float[](0., 0.000977272, 0.0057678, 0.0208262, 0.0550658, 0.117075, 0.210379, 0.330032, 0.465943, 0.602807, 0.727364, 0.829907, 0.906042, 0.956294, 0.984375, 0.996331, 0.998959, 1.);
    // voronoi.histogram = float[](0., 0.000335566, 0.000977272, 0.0025482, 0.0057678, 0.0114292, 0.0208262, 0.0348694, 0.0550658, 0.0821692, 0.117075, 0.159667, 0.210379, 0.26719, 0.330032, 0.396772, 0.465943, 0.534796, 0.602807, 0.667123, 0.727364, 0.781637, 0.829907, 0.871237, 0.906042, 0.934175, 0.956294, 0.972722, 0.984375, 0.991902, 0.996331, 0.998351, 0.998959, 1.);
    // voronoi.histogram = float[](0., 0.000193565, 0.000335566, 0.000574755, 0.000977272, 0.00160899, 0.0025482, 0.00389829, 0.0057678, 0.00822879, 0.0114292, 0.0155106, 0.0208262, 0.027162, 0.0348694, 0.0440788, 0.0550658, 0.0677061, 0.0821692, 0.0984756, 0.117075, 0.137335, 0.159667, 0.183893, 0.210379, 0.238113, 0.26719, 0.297832, 0.330032, 0.363021, 0.396772, 0.430832, 0.465943, 0.500346, 0.534796, 0.568858, 0.602807, 0.6354, 0.667123, 0.69764, 0.727364, 0.755259, 0.781637, 0.806393, 0.829907, 0.851416, 0.871237, 0.88937, 0.906042, 0.920899, 0.934175, 0.945849, 0.956294, 0.965156, 0.972722, 0.979054, 0.984375, 0.988565, 0.991902, 0.99446, 0.996331, 0.997554, 0.998351, 0.998754, 0.998959, 1.);
    // voronoi.histogram = float[](0., 0.000139302, 0.000193565, 0.000251067, 0.000335566, 0.000440312, 0.000574755, 0.000756711, 0.000977272, 0.00126047, 0.00160899, 0.00204201, 0.0025482, 0.0031513, 0.00389829, 0.00475867, 0.0057678, 0.00690732, 0.00822879, 0.00970712, 0.0114292, 0.0133576, 0.0155106, 0.0180069, 0.0208262, 0.023826, 0.027162, 0.0308494, 0.0348694, 0.0392542, 0.0440788, 0.0492515, 0.0550658, 0.0611735, 0.0677061, 0.0747076, 0.0821692, 0.0900902, 0.0984756, 0.107425, 0.117075, 0.126953, 0.137335, 0.148293, 0.159667, 0.171575, 0.183893, 0.196745, 0.210379, 0.224014, 0.238113, 0.252513, 0.26719, 0.282346, 0.297832, 0.313493, 0.330032, 0.3464, 0.363021, 0.379851, 0.396772, 0.413762, 0.430832, 0.448128, 0.465943, 0.483175, 0.500346, 0.517608, 0.534796, 0.551962, 0.568858, 0.585696, 0.602807, 0.619169, 0.6354, 0.651422, 0.667123, 0.682521, 0.69764, 0.712445, 0.727364, 0.741442, 0.755259, 0.768561, 0.781637, 0.794235, 0.806393, 0.818166, 0.829907, 0.840923, 0.851416, 0.861544, 0.871237, 0.880553, 0.88937, 0.897737, 0.906042, 0.913676, 0.920899, 0.92781, 0.934175, 0.940214, 0.945849, 0.951152, 0.956294, 0.960842, 0.965156, 0.969085, 0.972722, 0.976067, 0.979054, 0.981806, 0.984375, 0.986576, 0.988565, 0.990356, 0.991902, 0.993267, 0.99446, 0.995476, 0.996331, 0.996996, 0.997554, 0.997998, 0.998351, 0.998592, 0.998754, 0.998869, 0.998959, 1.);

    
    ProceduralProcess voronoi2 = voronoi;
    voronoi2.uv /= 2.;
    voronoi2.value = 1. - clamp(voronoi3d(vec3(voronoi2.uv, 0.), tmpvorcenter).r*.95 - 0.025, 0., 1.);

    float alpha = cos(_iTime*.5)*.5 + .5;
    alpha = 0.5;
    // alpha = cos(_iTime)*.25 + .25;
    // alpha = uv.x;

    ProceduralProcess in1 = voronoi;
    ProceduralProcess in2 = voronoi2;

    #define USED_MIXMAX MixMaxNaive_Flat
    // #define USED_MIXMAX MixMaxNaive_Original

    // #define USED_MIXMAX_MICRO MixMaxMicro_Original
    #define USED_MIXMAX_MICRO MixMaxMicro_Flat

    // #define USING_FLAT_PRIORITY

    #ifdef USING_FLAT_PRIORITY
        float p1 = ProceduralPriority_HIST_SIZE(in1);
        float p2 = ProceduralPriority_HIST_SIZE(in2);
    #else
        float p1 = in1.value;
        float p2 = in2.value;
    #endif

    vec2 mixmax = USED_MIXMAX(
        in1.value, p1,
        in2.value, 1.-p2,
        alpha
    );

    float basevariance = 0.001;
    vec2 mixmax_micro = USED_MIXMAX_MICRO(
        in1.value, p1, basevariance,
        in2.value, 1.-p2, basevariance,
        alpha
    );

    // fragColor.rgb = mix(vec3(1, 0, 0), vec3(0, 1, 0), mixmax_micro.r);
    fragColor.rgb = mix(in1.value, 1.-in2.value, mixmax_micro.r).rrr;
    // fragColor.rgb = mix(in1.value, 1.-in2.value, mixmax.r).rrr;
    // fragColor.rgb = 1.-mixmax.rrr;
    // fragColor.rgb = 1.-mixmax_micro.rrr;
    // fragColor.rgb = mixmax.ggg;
}